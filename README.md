# Ответы на вопросы из ТЗ

## 1) Почему выбрал такую структуру?
- Вся доменная логика сгруппирована по модулям (`src/modules/payment`), поэтому легко добавлять новые bounded context без затрагивания существующих.
- Общие инфраструктурные элементы вынесены в `src/shared` (сервер, плагины Fastify, DI, утилиты, системные адаптеры), что позволяет переиспользовать код и держать единые стандарты в одном месте.
- Конфигурация и интеграции (например, `awilix`, подключение SQLite, системные часы) регистрируются через DI-контейнер в `src/main.ts`, поэтому можно подменять реализации в тестах или при миграции на другие сервисы (Postgres, S3 и т.д.).
- Слои разделяют ответственность: HTTP-слой (роуты и плагины) тонкий, use-case слой управляет оркестрацией, а репозитории/адаптеры инкапсулируют работу с внешними ресурсами.

## 2) Как бы подключил Kafka для вебхуков?
- Создал бы инфраструктурный адаптер, который публикует каждое входящее вебхук-событие в отдельный Kafka.
- Параллельно поднял бы consumer (как отдельный Fastify worker либо фоновый сервис), который читает события, валидирует их и обрабатывает.

## 3) Как бы масштабировал решение при росте нагрузки?
- Сами вебхук-события складывал бы в Kafka, потому что их может приходить много и нужно буферизовать всплески.
- На уровне Node.js использовал бы `pm2` в режиме cluster, чтобы процесс автоматически поднимал воркеры по числу CPU и перезапускал их при сбоях.
- Расширил бы горизонтально веб-приложение (несколько экземпляров Fastify за балансировщиком) и вынес бы stateful части (SQLite → внешняя БД/Postgres, Redis для кэша/блокировок).
- Добавил бы отдельные consumer-воркеры для разных типов событий (создание платежа, ретрай, уведомления), чтобы масштабировать их независимо.
- Включил бы централизованное логирование/метрики (ELK + Elastic APM/Prometheus) и circuit breaker на внешние провайдеры, чтобы быстрее обнаруживать деградации.

## 4) Какие компромиссы сделал и почему?
- Не реализована идемпотентность при обработке вебхуков: события от платёжных систем могут приходить несколько раз.
- Логирование событий сведено к минимому; полноценные логи и трассировка (с кореляционными id) не добавлены.
- Не добавлен `API_WEBHOOK_KEY` для проверки источника вебхуков.

## Архитектура

Проект построен по принципам **Modular Monolith** с использованием элементов **Clean Architecture** и **Domain-Driven Design (DDD)**.

### Основные слои:

1.  **Presentation Layer (API)**:
    - Реализован на **Fastify**.
    - Находится в `src/modules/*/routes`.
    - Отвечает за валидацию входных данных и вызов Use Cases.

2.  **Application Layer (Use Cases)**:
    - Находится в `src/modules/*/use-cases`.
    - Содержит бизнес-сценарии приложения.
    - Оркестрирует работу доменных сущностей и инфраструктурных сервисов.

3.  **Domain Layer**:
    - Находится в `src/modules/*/domain`.
    - Содержит чистую бизнес-логику и типы.

4.  **Infrastructure Layer**:
    - Находится в `src/modules/*/database` и `src/shared`.
    - Реализует интерфейсы (порты), определенные в других слоях.
    - Включает работу с БД (Drizzle ORM + SQLite), системные утилиты и внешние интеграции.

